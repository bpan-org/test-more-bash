.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "STDIN 1"
.TH "test-tap" 3 "2022-12-13" "md2man v0.1.0" "TAP Testing for Bash"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "TEST-TAP-BASH"
.IX Header "TEST-TAP-BASH"
\&\s-1TAP\s0 Testing for Bash
.SS "\s-1SYNOPSIS\s0"
.IX Subsection "SYNOPSIS"
Write a test file like this. Maybe call it \f(CW\*(C`test/test.t\*(C'\fR:
.PP
.Vb 1
\&    #!/usr/bin/env bash
\&
\&    source bpan.bash \-\-
\&    bpan:source test\-tap
\&
\&    plan 10
\&
\&    ok "$(some\-command)" \*(Aqsome\-command is ok\*(Aq
\&
\&    # or:
\&    try some\-command
\&    ok "$rc" \e
\&       \*(Aqsome\-command is ok\*(Aq
\&
\&    try some\-bad\-command \-\-so\-bad
\&    has "$got" "bad bad bad" \e
\&      "some\-bad\-command error msg contained \*(Aqbad bad bad\*(Aq"
\&
\&    pass \*(AqThis will always pass\*(Aq
\&
\&    fail \*(AqThis will always fail\*(Aq
\&
\&    is $(echo foo) \*(Aqfoo\*(Aq \e
\&       \*(Aqfoo is foo\*(Aq
\&
\&    isnt foo bar \e
\&      "%G isn\*(Aqt %W"  # "foo isn\*(Aqt bar"
\&
\&    like food foo \e
\&      \*(Aqfood is like foo\*(Aq
\&
\&    unlike team I \e
\&      "There\*(Aqs no \*(AqI\*(Aq in \*(Aqteam\*(Aq"
\&
\&    diag "A message for stderr"
\&
\&    note "A message for stdout"
\&
\&    output=( $(ls) )
\&    expected=(README lib bin)
\&    array:is output expected \e
\&      "list files"
.Ve
.PP
Run the test with \f(CW\*(C`prove\*(C'\fR like this:
.PP
.Vb 2
\&    prove test/
\&    prove \-v test/test.t
.Ve
.PP
\&\f(CW\*(C`prove\*(C'\fR knows it's Bash from the first line (the shebang), and it just works.
.PP
You may also run the tests with \f(CW\*(C`bpan test ...\*(C'\fR which just calls \f(CW\*(C`prove ...\*(C'\fR.
.PP
\&\s-1BPAN\s0 modules generally have a Makefile where \f(CW\*(C`make test\*(C'\fR calls \f(CW\*(C`bpan test \-v test/\*(C'\fR.
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
Test::More <https://metacpan.org/pod/Test::More> is the tried and true testing library for Perl. It uses \s-1TAP\s0 (the Test Anything Protocol). This is the same thing for Bash. For the most part it should work exactly the same.
.SS "\s-1TEST TAP API FUNCTIONS\s0"
.IX Subsection "TEST TAP API FUNCTIONS"
In functions with \f(CW\*(C`[<label\*(C'\fR]>, the label is a (optional) string describing the test that gets printed when the tests are run with verbose (\f(CW\*(C`\-v\*(C'\fR) output.
.PP
The special \*(L"variables\*(R" \f(CW%G\fR and \f(CW%W\fR expand to the \f(CW\*(C`got\*(C'\fR and \f(CW\*(C`want\*(C'\fR string values respectively.
.PP
\&\s-1NOTE:\s0 The got and want values may be altered to fit better in a label string.
.IP "\(bu" 4
\&\f(CW\*(C`plan <number\*(C'\fR>
.Sp
Declare the expected number of tests to be run. If used, must be called before other functions. If not used, you must call \f(CW\*(C`done\-testing\*(C'\fR at the end.
.IP "\(bu" 4
\&\f(CW\*(C`plan skip\-all [<reason\*(C'\fR]>
.Sp
Use this version of \f(CW\*(C`plan\*(C'\fR if it is determined that the tests should \s-1NOT\s0 be run for some reason. Possible reasons are things like a missing command or a certain operating system.
.Sp
Can also be called using \f(CW\*(C`skip\-all [<reason\*(C'\fR]>.
.IP "\(bu" 4
\&\f(CW\*(C`done\-testing [<number\*(C'\fR]>
.Sp
Declare that all tests have been run, optionally with the expected number. If used, must be called after all other assertion functions. If not used, you must call \f(CW\*(C`plan\*(C'\fR at the start.
.IP "\(bu" 4
\&\f(CW\*(C`bail\-on\-fail\*(C'\fR
.Sp
Use this function to declare that any subsequent test failures should terminate the rest of the test script.
.IP "\(bu" 4
\&\f(CW\*(C`try <some command \-\-with=options\*(C'\fR>
.Sp
Try will run a command in a safe way and return the combined stdout and stderr in a variable called \f(CW\*(C`got\*(C'\fR. It will also put the status (return) code in a variable called \f(CW\*(C`rc\*(C'\fR. This is very useful for testing error messages without having the test script error out.
.IP "\(bu" 4
\&\f(CW\*(C`pass [<label\*(C'\fR]>
.Sp
An explicit passing test.
.IP "\(bu" 4
\&\f(CW\*(C`fail [<label\*(C'\fR]>
.Sp
An explicit failing test.
.IP "\(bu" 4
\&\f(CW\*(C`ok "$(<cmd\*(C'\fR)" [<label>]>
.Sp
Pass if cmd runs with a 0 (zero) exit status. You may also call \f(CW\*(C`ok\*(C'\fR with a status code (0\-255) instead of a command. Commands should be formatted like: \f(CW"$( command args... )"\fR; that is wrapped in \f(CW"$(...)"\fR (with actual double quotes).
.IP "\(bu" 4
\&\f(CW\*(C`not\-ok "$(<cmd\*(C'\fR)" [<label>]>
.Sp
Pass if cmd runs with a non-zero exit status. Same rules as \f(CW\*(C`ok\*(C'\fR, but meaning is opposite.
.IP "\(bu" 4
\&\f(CW\*(C`is <got\*(C'\fR <want> [<label>]>
.Sp
Pass if got is equal to want. If want is a multiline string, print a unified diff on failure.
.IP "\(bu" 4
\&\f(CW\*(C`isnt <got\*(C'\fR <unwanted> [<label>]>
.Sp
Pass if got is \s-1NOT\s0 equal to want. Opposite of \f(CW\*(C`is\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`like <got\*(C'\fR <regex> [<label>]>
.Sp
Pass if got matches regex (bash regular expression).
.IP "\(bu" 4
\&\f(CW\*(C`unlike <got\*(C'\fR <regex> [<label>]>
.Sp
Pass if got doesn't match regex (bash regular expression). Opposite of \f(CW\*(C`like\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`has <got\*(C'\fR <want> [<label>]>
.Sp
Pass if got contains the want string.
.IP "\(bu" 4
\&\f(CW\*(C`hasnt <got\*(C'\fR <want> [<label>]>
.Sp
Pass if got does \s-1NOT\s0 contain the want string. Opposite of \f(CW\*(C`has\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`array:is <got\-array\-var\-name\*(C'\fR <want\-array\-var\-name> [<label>]>
.Sp
Pass if the got array has content equal to the want array.
.IP "\(bu" 4
\&\f(CW\*(C`diag <msg\*(C'\fR>
.Sp
Print a message to stderr in a way that the harness knows how to process.
.IP "\(bu" 4
\&\f(CW\*(C`note <msg\*(C'\fR>
.Sp
Print a message to stdout in a way that the harness knows how to process.
.IP "\(bu" 4
\&\f(CW\*(C`bail\-out [<reason\*(C'\fR]>
.Sp
Stop the test script in a way that the harness knows how to process.
.PP
\fIFile System Test Functions\fR
.IX Subsection "File System Test Functions"
.PP
Functions called \f(CW\*(C`ok\-?\*(C'\fR are really just calling \f(CW\*(C`[[ \-? ... ]]\*(C'\fR. For example \f(CW\*(C`ok\-f /path/to/file\*(C'\fR calls \f(CW\*(C`[[ \-f /path/to/file ]]\*(C'\fR.
.PP
You can use a label for the following test funtions, but they will create appropriate labels for you if you don't. Therefore best practice is to not use labels when calling the following functions.
.IP "\(bu" 4
\&\f(CW\*(C`ok\-d <path\*(C'\fR>
.Sp
Pass if path is an existing directory (or a link to a directory).
.IP "\(bu" 4
\&\f(CW\*(C`ok\-e <path\*(C'\fR>
.Sp
Pass if path exists.
.IP "\(bu" 4
\&\f(CW\*(C`ok\-not\-e <path\*(C'\fR>
.Sp
Pass if path does \s-1NOT\s0 exist.
.IP "\(bu" 4
\&\f(CW\*(C`ok\-empty <path\*(C'\fR>
.Sp
Pass if path is an empty file or directory.
.IP "\(bu" 4
\&\f(CW\*(C`ok\-f <path\*(C'\fR>
.Sp
Pass if path is a file (or a link to a file).
.IP "\(bu" 4
\&\f(CW\*(C`ok\-h <path\*(C'\fR>
.Sp
Pass if path is a symlink.
.IP "\(bu" 4
\&\f(CW\*(C`ok\-s <path\*(C'\fR>
.Sp
Pass if path is a non-empty file.
.IP "\(bu" 4
\&\f(CW\*(C`ok\-w <path\*(C'\fR>
.Sp
Pass if path is writable.
.IP "\(bu" 4
\&\f(CW\*(C`ok\-x <path\*(C'\fR>
.Sp
Pass if path is executable.
.SS "\s-1AUTHOR\s0"
.IX Subsection "AUTHOR"
Ingy do\*:t Net ingy@ingy.net <mailto:ingy@ingy.net>
.SS "\s-1COPYRIGHT & LICENSE\s0"
.IX Subsection "COPYRIGHT & LICENSE"
Copyright 2013\-2022 \- Ingy do\*:t Net
.PP
The \s-1MIT\s0 License (\s-1MIT\s0)
